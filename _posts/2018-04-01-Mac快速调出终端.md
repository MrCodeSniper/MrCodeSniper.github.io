---
layout:     post
title:      View机制解析
subtitle:   在Mac下为终端设置快捷键
date:       2018-04-01
author:     BY
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Mac
    - 效率
    - 开发技巧
---

>我们之前分析Window机制时已经清楚的理解了我们设置的View 就是DecorView的mContentParent下的View树

![](https://img-blog.csdn.net/20150528211309106)

## 起点


### WindowManagerGlobal
DecorView通过 WindowManager添加view到window显示与用户交互

而**ViewRootImpl** 是用来连接 WindowManager 和 DecorView 的桥梁

在 WindowManagerGlobal 的 addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) 方法中，创建了 ViewRootImpl 对象，将 ViewRootImpl 和 DecorView 相关联 root.setView(view, wparams, panelParentView);


Android中的任何一个布局、任何一个控件其实都是直接或间接继承自View实现的
这些View应该都具有相同的绘制流程与机制才能显示到屏幕上
每一个View的绘制过程都必须经历三个最主要的过程，也就是measure、layout和draw。

而整个view树的绘制就是通过ViewRootImpl将decorview绘制完成交由WindowManager在window上显示

### ViewRootImpl


```java
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
       synchronized (this) {
           if (mView == null) {
			// 将 decorView 设置给全局的 mView
               mView = view;
			...
			// 标记已经添加了 decorView
			mAdded = true;
			...
			// 第一次发起布局，在添加到 WindowManager 之前
			// 确保在接收其他系统事件之前完成重新布局
			requestLayout();
			...
			// 利用 mWindowSession 以跨进程的方式向 WMS 发起一个调用，从而将DecorView 最终添加到 Window 上
		  	try {
		  	    mOrigWindowType = mWindowAttributes.type;
		  	    mAttachInfo.mRecomputeGlobalAttributes = true;
		  	    collectViewAttributes();
		  	    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(),        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel);
               } 
			...
		}
	}
}
```

这个源码方法的重点在与requestLayout(); 它是绘制步骤的关键我们继续深入


```java
 @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }

```

最终调用scheduleTraversals();

```java
 void scheduleTraversals() {
       if (!mTraversalScheduled) {
           mTraversalScheduled = true;
           mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
		// 发送消息，调用 mTraversalRunnable
           mChoreographer.postCallback(
                   Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
           if (!mUnbufferedInputDispatch) {
               scheduleConsumeBatchedInput();
           }
           notifyRendererOfFramePending();
           pokeDrawLockIfNeeded();
       }
   }

final TraversalRunnable mTraversalRunnable = new TraversalRunnable();

   final class TraversalRunnable implements Runnable {
       @Override
       public void run() {
		// 内部调用了 performTraversals()
           doTraversal();
       }
   }
```

在主线程调用doTraversal(); 最后在深入还是要看performTraversals()

```java
private void performTraversals() {

	// 计算 Activity 中 window 的宽高等等
	...

	if (!mStopped || mReportNextDraw) {
               boolean focusChangedDueToTouchMode = ensureTouchModeLocally(
                       (relayoutResult&WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
               if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()
                       || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||
                       updatedConfiguration) {
                   // 得到 view 宽高的规格
                   // mWidth 和 mHeight 即用来描述 Activity 窗口宽度和高度
                   // lp.width 和 lp.height 就是 DecorView 的宽高
                   int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                   int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);

                   if (DEBUG_LAYOUT) Log.v(mTag, "Ooops, something changed!  mWidth="
                           + mWidth + " measuredWidth=" + host.getMeasuredWidth()
                           + " mHeight=" + mHeight
                           + " measuredHeight=" + host.getMeasuredHeight()
                           + " coveredInsetsChanged=" + contentInsetsChanged);

                    // Ask host how big it wants to be
                    // 开始执行测量工作，测量是从这里发起的
                   performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);

                   // Implementation of weights from WindowManager.LayoutParams
                   // We just grow the dimensions as needed and re-measure if
                   // needs be
                   int width = host.getMeasuredWidth();
                   int height = host.getMeasuredHeight();
                   boolean measureAgain = false;

                   // 检查是否需要重新测量
                   if (lp.horizontalWeight > 0.0f) {
                       width += (int) ((mWidth - width) * lp.horizontalWeight);
                       childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,
                               MeasureSpec.EXACTLY);
                       measureAgain = true;
                   }
                   if (lp.verticalWeight > 0.0f) {
                       height += (int) ((mHeight - height) * lp.verticalWeight);
                       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,
                               MeasureSpec.EXACTLY);
                       measureAgain = true;
                   }

                   // 需要再次测量的话，就再执行一遍 performMeasure
                   if (measureAgain) {
                       if (DEBUG_LAYOUT) Log.v(mTag,
                               "And hey let's measure once more: width=" + width
                               + " height=" + height);
                       performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                   }

                   layoutRequested = true;
               }
           }

	...

       final boolean didLayout = layoutRequested && (!mStopped || mReportNextDraw);
       boolean triggerGlobalLayoutListener = didLayout
               || mAttachInfo.mRecomputeGlobalAttributes;
       if (didLayout) {
           // 执行布局工作，布局是从这里发起的
           performLayout(lp, mWidth, mHeight);

	...

	if (!cancelDraw && !newSurface) {
           if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
               for (int i = 0; i < mPendingTransitions.size(); ++i) {
                   mPendingTransitions.get(i).startChangingAnimations();
               }
               mPendingTransitions.clear();
           }
           // 执行绘制工作，绘制是从这里发起的
           performDraw();
       } 

	...

}
```
 
performTraversals() 方法的代码很长很长，但是我们关注点就可以放在三大流程上。其他的代码因为自己能力欠缺，并不能一一说出这些代码的作用。所以我们接下来就把重点放在：

1.getRootMeasureSpec

2.performMeasure

3.performLayout

4.performDraw


#### getRootMeasureSpec
```java
windowSizeMayChange |= measureHierarchy(host, lp, res,
        desiredWindowWidth, desiredWindowHeight);
```

在 measureHierarchy 方法中已经调用了 performMeasure 来进行测量 这里只是为了确定 window 的大小而做的测量辅助

在 measureHierarchy 中，确定了 DecorView 的 MeasureSpec 。其中 childWidthMeasureSpec 和 childHeightMeasureSpec 即为 DecorView 对应的 MeasureSpec 。


```java
private static int getRootMeasureSpec(int windowSize, int rootDimension) {
    int measureSpec;
    switch (rootDimension) {

    case ViewGroup.LayoutParams.MATCH_PARENT:
        // Window can't resize. Force root view to be windowSize.
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
        break;
    case ViewGroup.LayoutParams.WRAP_CONTENT:
        // Window can resize. Set max size for root view.
        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
        break;
    default:
        // Window wants to be an exact size. Force root view to be that size.
        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
        break;
    }
    return measureSpec;
}
```

如果是 MATCH_PARENT ，那么对应的就是窗口大小；

如果是 WRAP_CONTENT ，那么不能超过窗口大小；

固定大小，那么就是大小就是传入的 lp.width/lp.height 了。


ViewGroup中 计算子 View 测量规格的 getChildMeasureSpec 方法

也是根据父容器的规格确定子容器

具体可用这张图表示

![](http://ofyt9w4c2.bkt.clouddn.com/20170918/20170821150637571.png)


**总结：对于 DecorView 来说，其 MeasureSpec 是由窗口的大小和自身的 LayoutParams 来共同决定的；而对于普通的 View 来说，其 MeasureSpec 是由父容器的 MeasureSpec 和自身的 LayoutParams 共同决定的。**




#### performMeasure

```java
private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure");
    try {
        // 进行测量
        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
```

在 performMeasure 中调用了 measure 方法。说到底，DecorView 只是一个View所以我们又要进入 View 类中去看下。

View 的 measure 方法内部是调用了 onMeasure

这里小提一下，我们都知道 DecorView 其实是一个 FrameLayout ，所以 onMeasure 应该在 FrameLayout 中去看

```java
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int count = getChildCount();
    // 判断当前 framelayout 布局的宽高是否至少一个是 match_parent 或者精确值 ，如果是则置 measureMatchParent 为 false .
    final boolean measureMatchParentChildren =
            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||
            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;
    mMatchParentChildren.clear();

    int maxHeight = 0;
    int maxWidth = 0;
    int childState = 0;

    // 遍历不为 GONE 的子 view
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (mMeasureAllChildren || child.getVisibility() != GONE) {
            // 对每一个子 View 进行测量
            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            // 寻找子 View 中宽高的最大者，因为如果 FrameLayout 是 wrap_content 属性
            // 那么它的宽高取决于子 View 中的宽高最大者
            maxWidth = Math.max(maxWidth,
                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
            maxHeight = Math.max(maxHeight,
                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
            childState = combineMeasuredStates(childState, child.getMeasuredState());
            // 如果 FrameLayout 为 wrap_content 且 子 view 的宽或高为 match_parent ，那么就添加到 mMatchParentChildren 中
            if (measureMatchParentChildren) {
                if (lp.width == LayoutParams.MATCH_PARENT ||
                        lp.height == LayoutParams.MATCH_PARENT) {
                    mMatchParentChildren.add(child);
                }
            }
        }
    }

    // Account for padding too
    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();
    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();

    // Check against our minimum height and width
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());

    // Check against our foreground's minimum height and width
    final Drawable drawable = getForeground();
    if (drawable != null) {
        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
    }
    //设置测量结果
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
            resolveSizeAndState(maxHeight, heightMeasureSpec,
                    childState << MEASURED_HEIGHT_STATE_SHIFT));

    // 子View中设置为match_parent的个数
    count = mMatchParentChildren.size();
    // 若 FrameLayout 为 wrap_content 且 count > 1
    if (count > 1) {
        for (int i = 0; i < count; i++) {
            final View child = mMatchParentChildren.get(i);
            final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

            // 如果子 View 的宽度是 match_parent 属性，那么对 childWidthMeasureSpec 修改：
            // 把 widthMeasureSpec 的宽度修改为:framelayout总宽度 - padding - margin，模式设置为 EXACTLY
            final int childWidthMeasureSpec;
            if (lp.width == LayoutParams.MATCH_PARENT) {
                final int width = Math.max(0, getMeasuredWidth()
                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()
                        - lp.leftMargin - lp.rightMargin);
                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(
                        width, MeasureSpec.EXACTLY);
            } else {
                // 否则就按照正常的来就行了
                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +
                        lp.leftMargin + lp.rightMargin,
                        lp.width);
            }

            // 高度同理
            final int childHeightMeasureSpec;
            if (lp.height == LayoutParams.MATCH_PARENT) {
                final int height = Math.max(0, getMeasuredHeight()
                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()
                        - lp.topMargin - lp.bottomMargin);
                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(
                        height, MeasureSpec.EXACTLY);
            } else {
                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,
                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +
                        lp.topMargin + lp.bottomMargin,
                        lp.height);
            }
            //对于这部分的子 View 需要重新进行 measure 过程
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}
```

其实总的来说重要的就只有遍历 child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 这个方法，这是将父容器的 measure 过程传递到子 View 中。

而子 View 被父容器调用了 measure 后，也会调用属于自己的 onMeasure 方法

```java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
```
在onMeasure源码中设置宽高尺寸 使用了getDefaultSize,我们在看下getDefaultSize的源码

```java
public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        //通过MeasureSpec解析获取mode与size 即前两位和后三十位
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
//父控件对子控件不加任何束缚，子元素可以得到任意想要的大小
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST://父控件为子View指定确切大小
        case MeasureSpec.EXACTLY://父控件为子元素指定最大参考尺寸
            result = specSize;
            break;
        }
        return result;
    }
```

若是 UNSPECIFIED ，则直接返回的就是 getSuggestedMinimumWidth/getSuggestedMinimumHeight 的值；

若是 AT_MOST/EXACTLY ，直接用的就是 specSize 。

而根据我们之前总结出来的表可知，只要 view 不指定固定大小，那么无论是 AT_MOST 还是 EXACTLY ，都是按照 parentSize 来的。


## 小结

我们把整个过程梳理以下


WindowManagerGlobal.addView()中代码root = new ViewRootImpl(view.getContext(), display)创建了ViewRootImp
WindowManagerGlobal.addView()中又调用了ViewRootImp的setView(view, wparams, panelParentView) 与decorview关联

---------并在其中调用了requestLayout();
        
------------其中调用了 scheduleTraversals(); 
            
--------------其中在主线执行doTraversal();
                
----------------其中执行performTraversals();
                    
---------------------其中执行了measureHierarchy根据view的大小跳转window大小

————————————————————————接着调用了performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                         
---------------------------其中执行了DecorView.measure
                            
------------------------------其中执行了DecorView.onMeasure
                                
--------------------------------- 其中循环执行了measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);

--------------------------------- 1.ViewGroup.measure->ViewGroup.onMeasure -> ViewGroup.measureChildWithMargins

--------------------------------- 2.View.measure -> View.onMeasure                
                                    
————————————————————————接着调用了performLayout(lp, desiredWindowWidth, desiredWindowHeight);

————————————————————————接着调用了performDraw();



注：DecorView 其实就是 FrameLayout










