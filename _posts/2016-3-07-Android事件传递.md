---
layout:     post
title:      Android事件传递
subtitle:   源码解析
date:       2016-03-07
author:     BY
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Mac
    - 效率
    - 开发技巧
---

> 以native为终点的源码分析



## Android中点击事件的来源 - 如何从硬件->Activity

先来看下这张图

![](http://ofyt9w4c2.bkt.clouddn.com/20170928/20170928102356.jpg)

事件首先产生是在Activity，那么又是谁将事件传给activity

核心的代码是mWindow.setCallback(this); 是PhoneWindow传的 接着我们就继续深入

首先，点击事件是由用户的触摸行为所产生的，因此它必须要通过硬件来捕获，然后点击事件会交给WMS来处理

我们知道Activity启动以后，在它的onResume以后，DecorView才开始attach给WindowManager从而显示出来

接着，系统就会完成添加Window的过程 在这个过程中一个很重要的角色被创建了

**root = new ViewRootImpl(view.getContext(), display);**

在ViewRootImpl的setView方法中，会通过跨进程的方式向WMS（WindowManagerService）发起一个调用，从而将DecorView最终添加到Window上

同时会创建InputChannel、InputQueue和WindowInputEventReceiver来接受点击事件的消息

这些类中都有native的dispatchInputEvent接受底层传输的事件

InputEvent有2个子类：KeyEvent和MotionEvent，其中KeyEvent表示键盘事件，而MotionEvent表示触摸事件

最终会通过deliverInputEvent方法 ，事件会经过分发由对应的InputStage处理（stage.deliver）而触摸事件由ViewPostImeInputStage处理

经过processPointerEvent方法 会调用boolean handled = mView.dispatchPointerEvent(event); 这个mView是引用的decorview

decorview本身没有这个方法 调用父类view的方法

```java
public final boolean dispatchPointerEvent(MotionEvent event) {
        if (event.isTouchEvent()) {
            return dispatchTouchEvent(event);
        } else {
            return dispatchGenericMotionEvent(event);
        }
    }
```

判断是否是触摸事件或者是一般移动事件,若是触摸事件则执行dispatchTouchEvent(event) 再来看看decorview重写的这个方法

```java
@Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        final Window.Callback cb = mWindow.getCallback();
        return cb != null && !mWindow.isDestroyed() && mFeatureId < 0
                ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);
    }
```

这里mWindow.getCallback()就是我们之前mWindow.setCallback(this)设置的activity，然后执行cb.dispatchTouchEvent(ev)
这样触摸事件就传给了Activity 

绕了一个大圈 触摸事件成功从wms获取到给activity

## Activity->ViewGroup





## ViewGroup->View



