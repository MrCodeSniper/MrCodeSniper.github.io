---
layout:     post
title:    Androidå¼‚æ­¥æŠ€æœ¯
subtitle: Â  æŠ€æœ¯è€ƒé‡å’Œæºç æ¢ç©¶
date: Â  Â  Â  2017-04-20
author:     MrCodeSniper
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - android
    - FrameWork
 Â  Â - å¼‚æ­¥
---



> ä¸²è¡Œï¼šä¾æ¬¡æ‰§è¡Œå¤šä¸ªçº¿ç¨‹ä»»åŠ¡ ã€‚å¹¶è¡Œï¼šä¸€èµ·æ‰§è¡Œå¤šä¸ªçº¿ç¨‹ä»»åŠ¡(æˆ–è€…è¯´ç»™æ¯ä¸ªçº¿ç¨‹åˆ†é…ä¸å›ºå®šçš„æ‰§è¡Œæ—¶é—´)ã€‚


# å‰è¨€

Androidå¹³å°åŸç”Ÿå°±æä¾›äº†éå¸¸ä¸°å¯Œçš„å¼‚æ­¥å¤„ç†æŠ€æœ¯ï¼Œé€‰æ‹©æ—¶éœ€è¦è€ƒè™‘å…·ä½“ä¸šåŠ¡éœ€æ±‚è€Œå®š
ä½†ä»¥ä¸‹è¿™äº›éƒ½æ˜¯æˆ‘ä»¬å¿…é¡»è€ƒé‡çš„èŒƒç•´

1.å°½é‡ä½¿ç”¨æ›´å°‘çš„cpuå’Œå†…å­˜

2.ä¸ºåº”ç”¨æä¾›æ›´å¥½çš„æ€§èƒ½ä¸æ›´å¿«çš„å“åº”

3.å®ç°ä½¿ç”¨å¤æ‚æ€§ä½

4.ä»£ç æ˜¯å¦ç¬¦åˆè§„èŒƒæ˜¯å¦æ˜“äºç»´æŠ¤

# æ­£æ–‡

## Thread

æˆ‘ä»¬çŸ¥é“è¿›ç¨‹æ˜¯æ“ä½œç³»ç»Ÿèµ„æºè°ƒåº¦å’Œåˆ†é…çš„åŸºæœ¬å•ä½
è€Œçº¿ç¨‹ä½œä¸ºè¿›ç¨‹çš„ç»„æˆéƒ¨åˆ†ï¼Œè¿›ç¨‹çš„æ‰€æœ‰çº¿ç¨‹å…±äº«æ‰€åœ¨è¿›ç¨‹çš„èµ„æº
çº¿ç¨‹ä½œä¸ºå®é™…æ‰§è¡Œä»»åŠ¡çš„åŸºæœ¬å•å…ƒ å¦‚ä½•æ§åˆ¶å¦‚ä½•ä½¿ç”¨æ˜¯Androidä¸­ä¸€ä¸ªéå¸¸é‡è¦çš„è¯¾é¢˜ã€‚

```java
public class Thread implements Runnable {
 Â .....//å®ç°Runnableæ¥å£
}

public  interface Runnable {//Runnableæ¥å£è§„å®šäº†æ‰§è¡Œå…·ä½“ä¸šåŠ¡é€»è¾‘ä»£ç çš„åŠŸèƒ½
 Â  Â public abstract void run();
}
```

è€Œandroidçš„threadæ˜¯åŸºäºlinuxå†…æ ¸çš„pthreadså®ç°çš„

### åˆ›å»ºThread

1.è‡ªå®šä¹‰ç±»ç»§æ‰¿Threadåœ¨runå‡½æ•°ä¸­é‡å†™å…·ä½“é€»è¾‘
```java
public  MyThread extends Thread{}
MyThread  mt=new MyThread();
mt.start();
```

2.è‡ªå®šä¹‰Runnable å…¶ä¸­åŒ…å«å…·ä½“runå‡½æ•°é€»è¾‘ä½œä¸ºå‚æ•°ä¼ å…¥Threadæ„é€ æ–¹æ³•å¹¶æ‰§è¡Œ
```java
new Thread(Runnable runnable).start();
```

### åº”ç”¨å±‚çº¿ç¨‹ç±»å‹

1.ä¸»çº¿ç¨‹

åˆ·æ–°ui,è¿è¡Œandroidç»„ä»¶

2.åå°çº¿ç¨‹

ä¹Ÿå«åšå·¥ä½œçº¿ç¨‹ ç¨‹åºå‘˜åˆ›å»ºçš„çº¿ç¨‹é»˜è®¤ä¸ºå­çº¿ç¨‹ éœ€è¦è‡ªå·±å®ç°æ‰§è¡Œä½“
åœ¨Linuxç³»ç»Ÿä¸­ ä¸»çº¿ç¨‹å’Œåå°çº¿ç¨‹æ˜¯ä¸€æ ·çš„ æ˜¯åœ¨WindowManagerä¸­å‡ºç°äº†åˆ†æ­§

3.Binderçº¿ç¨‹

å®ç°ä¸åŒè¿›ç¨‹é—´çº¿ç¨‹çš„é€šä¿¡       
ä¾‹å¦‚æœåŠ¡è¿›ç¨‹çš„æ³¨å†ŒæœåŠ¡çº¿ç¨‹ å®¢æˆ·è¿›ç¨‹çš„è·å–æœåŠ¡çº¿ç¨‹çº¿ç¨‹ ï¼ŒContentProvideræ•°æ®å¤„ç†çº¿ç¨‹ç­‰


## Threadæ‰©å±•

### 1.HandlerThread

HandlerThreadæ˜¯Threadçš„å­ç±» å®ƒçš„å®šä½ä¸º:å¯ä»¥å®ç°å¼‚æ­¥æ“ä½œçš„å­çº¿ç¨‹ 

æˆ‘ä»¬è¿›æºç çœ‹çœ‹å§(è¿™é‡Œåªæ”¾äº†æœ‰å…³çš„ä»£ç )

```java
Looper mLooper;//åœ¨å…¨å±€ä¸­å¼•å…¥äº†
protected void onLooperPrepared() {}//æä¾›äº†looperå¾ªç¯é˜Ÿåˆ—å‰çš„å¤å†™å‡½æ•°
@Override
    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        // å†…éƒ¨sThreadLocal.set(new Looper(quitAllowed));
        synchronized (this) {
            mLooper = Looper.myLooper();//return sThreadLocal.get();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }
//ps:ThreadLocalç»´æŠ¤å˜é‡æ—¶ï¼ŒThreadLocalä¸ºæ¯ä¸ªä½¿ç”¨è¯¥å˜é‡çš„çº¿ç¨‹æä¾›ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œæ‰€ä»¥æ¯ä¸€ä¸ªçº¿ç¨‹éƒ½å¯ä»¥ç‹¬ç«‹åœ°æ”¹å˜è‡ªå·±çš„å‰¯æœ¬ï¼Œè€Œä¸ä¼šå½±å“å…¶å®ƒçº¿ç¨‹æ‰€å¯¹
//åº”çš„å‰¯æœ¬.æ­¤å¤„looperåˆ›å»ºå¹¶å­˜æ”¾åœ¨ThreadLocalä¸­
 Â  Â public Looper getLooper() {
        if (!isAlive()) {
            return null;
        }
        
        // If the thread has been started, wait until the looper has been created.
        synchronized (this) {
            while (isAlive() && mLooper == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        return mLooper;
    }
```

æˆ‘ä»¬ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹ï¼Œä»–åœ¨runæ–¹æ³•ä¸­åˆ›å»ºäº†Looperè€ŒLooperä¸­æŒæœ‰MessageQueueçš„å¼•ç”¨ï¼Œè€Œä¸”æä¾›äº†åˆ›å»ºä¸æ­¤looperå…³è”çš„handler
è¿™æ ·å­çº¿ç¨‹å°±å…·å¤‡äº†å¤„ç†æ¶ˆæ¯çš„èƒ½åŠ›ï¼Œé€šè¿‡handlerå¯ä»¥è®©ä¸»çº¿ç¨‹å‘å­çº¿ç¨‹å‘é€ä¿¡æ¯ å®ç°äº†å¼‚æ­¥é€šä¿¡

ä¼˜ç‚¹ï¼šç®€å•æ˜“ç”¨å®ç°å¼‚æ­¥é€šä¿¡ çº¿ç¨‹å®‰å…¨
ç¼ºç‚¹ï¼šé˜Ÿåˆ—ä¸­ä»»åŠ¡å¯èƒ½ä¼šå‡ºç°å µå¡


#### IntentService

....


### 2.Executors FrameWork (çº¿ç¨‹ç®¡ç†æ¡†æ¶)

è¿™ä¸ªæ¡†æ¶ä¸ºandroidç³»ç»Ÿæä¾›çš„åŠŸèƒ½ï¼š
1.åˆ›å»ºçº¿ç¨‹æ± ç®¡ç†çº¿ç¨‹
2.æ£€æµ‹çº¿ç¨‹é”™è¯¯
3.æ‰¹é‡é¡ºåºæ‰§è¡Œè¿›ç¨‹
4.ç­‰å¾…è¿›ç¨‹æ‰§è¡Œå®Œæˆï¼Œè·å–è¿›ç¨‹æ‰§è¡Œç»“æœ

å®ƒæä¾›çš„åŠŸèƒ½èƒ½ä½¿ç”¨æˆ·èƒ½è‡ªå®šä¹‰è‡ªå·±çš„çº¿ç¨‹ç®¡ç†å·¥å…·

è¿™ä¸ªæ¡†æ¶çš„åŸºç¡€æ¥å£Executoræ¥å£è§„å®šäº†çº¿ç¨‹ä»»åŠ¡çš„æ‰§è¡Œ
è€Œè‡ªå®šä¹‰çº¿ç¨‹æ± æ˜¯ä»¥ThreadPoolExecutorä¸ºåŸºç¡€

```java
ThreadPoolExecutor tp1= (ThreadPoolExecutor) Executors.newFixedThreadPool(5);//åˆ›å»ºå›ºå®šå¤§å°çš„çº¿ç¨‹æ± 
ThreadPoolExecutor tp2= (ThreadPoolExecutor)Executors.newCachedThreadPool();//æ–°ä»»åŠ¡ä¼šåˆ›å»ºæ–°çº¿ç¨‹å¤„ç† ç©ºé—²ä¹…çš„çº¿ç¨‹ä¼šé”€æ¯ å¯å˜å¤§å°å…ˆåƒ
ThreadPoolExecutor tp3= (ThreadPoolExecutor)Executors.newSingleThreadExecutor(); //å•ä¸ªçº¿ç¨‹å¤„ç†å•ä¸ªä»»åŠ¡
```

psï¼šæ ¸å¿ƒçº¿ç¨‹æ•°ï¼šæ ¸å¿ƒçº¿ç¨‹ä¼šä¸€ç›´åœ¨çº¿ç¨‹æ± ä¸­ å³ä½¿æ²¡æœ‰ä»»åŠ¡è¦å¤„ç† å³ä½¿æœ‰ç©ºé—²çº¿ç¨‹ ä¹Ÿä¼šåˆ›å»ºæ–°çš„çº¿ç¨‹ç›´åˆ°è¾¾åˆ°æ ¸å¿ƒçº¿ç¨‹æ•°

#### AsyncTask(çº¿ç¨‹ç®¡ç†æ¡†æ¶çš„æ‰©å±•)

AsyncTaskæˆ‘ä»¬éå¸¸ç†Ÿæ‚‰çš„ç”¨æ¥å¤„ç†å¼‚æ­¥ä»»åŠ¡çš„ç±» æ˜¯å¯¹Executorsæ¡†æ¶çš„å°è£…,å…¶å®ä¸ºçº¿ç¨‹æ± +handlerçš„ç»„åˆ

```java
new AsyncTask<Void,Void,Void>(){

            @Override
            protected Void doInBackground(Void... voids) {
                //åªæœ‰è¿™ä¸ªæ–¹æ³•åœ¨å­çº¿ç¨‹æ‰§è¡Œ
                return null;
            }


            @Override
            protected void onPostExecute(Void aVoid) {
                super.onPostExecute(aVoid);
            }
        }.execute();
```

è®©æˆ‘ä»¬æ·±å…¥æºç çœ‹çœ‹

```java
public abstract class AsyncTask<Params, Progress, Result> {
    ...//AsyncTask ä¸ºæŠ½è±¡ç±»ï¼Œå…¶ä¸­æœ‰ä¸‰ä¸ªæ³›å‹ã€‚ç¬¬ä¸€ä¸ªæ˜¯ä¼ é€’çš„å‚æ•°ç±»å‹ï¼Œç¬¬äºŒä¸ªæ˜¯ä»»åŠ¡æ‰§è¡Œçš„è¿›åº¦ï¼Œç¬¬ä¸‰ä¸ªæ˜¯ä»»åŠ¡æ‰§è¡Œçš„ç»“æœç±»å‹äº†ã€‚
}
```

1.çº¿ç¨‹æ± 

```java
private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;//æ ¸å¿ƒçº¿ç¨‹æ•°ä¸º CPU çš„æ ¸å¿ƒæ•°é‡ + 1
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;//æœ€å¤§çº¿ç¨‹æ•°ä¸º CPU çš„æ ¸å¿ƒæ•°é‡ * 2 + 1
private static final int KEEP_ALIVE = 1;//è¿‡å‰©çº¿ç¨‹çš„å­˜æ´»æ—¶é—´ä¸º1s

private static final ThreadFactory sThreadFactory = new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);

    public Thread newThread(Runnable r) {
        return new Thread(r, "AsyncTask #" + mCount.getAndIncrement());
    }
};

private static final BlockingQueue<Runnable> sPoolWorkQueue=//sPoolWorkQueueé˜»å¡å¼çº¿ç¨‹é˜Ÿåˆ—æœ€å¤§ä¸ªæ•°ä¸º128å³ä»»åŠ¡å¤„ç†æ•°+ä»»åŠ¡ç­‰å¾…æ•°>128ä¼šå‡ºç°å¼‚å¸¸
 Â  Â  Â  Â new LinkedBlockingQueue<Runnable>(128);

/**
 * An {@link Executor} that can be used to execute tasks in parallel.
 */
public static final Executor THREAD_POOL_EXECUTOR
        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
```

2.æ‰§è¡Œå™¨

```java
public static final Executor SERIAL_EXECUTOR = new SerialExecutor();

private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;

private static class SerialExecutor implements Executor {
    final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
```
AsyncTaské»˜è®¤æ‰§è¡Œå™¨å³SerialExecutor 

å¯ä»¥ä» SerialExecutor çš„å†…éƒ¨çœ‹åˆ°ï¼Œæ˜¯å¾ªç¯åœ°å–å‡º mActive ï¼Œå¹¶ä¸”æŠŠ mActive æ”¾ç½®åˆ°ä¸Šé¢çš„ THREAD_POOL_EXECUTOR ä¸­å»æ‰§è¡Œ

è¿™æ„å‘³ç€æ‰§è¡Œå™¨å’Œä»»åŠ¡éƒ½æ˜¯ä¸²è¡Œä¸€ä¸ªä¸ªè¿è¡Œçš„


3.Handler

```java
private static InternalHandler sHandler;

private static final int MESSAGE_POST_RESULT = 0x1;
private static final int MESSAGE_POST_PROGRESS = 0x2;

private static class InternalHandler extends Handler {
    public InternalHandler() {
        super(Looper.getMainLooper());
    }

    @SuppressWarnings({"unchecked", "RawUseOfParameterizedType"})
    @Override
    public void handleMessage(Message msg) {
        AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;
        switch (msg.what) {
            case MESSAGE_POST_RESULT:
                // There is only one result
                result.mTask.finish(result.mData[0]);
                break;
            case MESSAGE_POST_PROGRESS:
                result.mTask.onProgressUpdate(result.mData);
                break;
        }
    }
}

private void finish(Result result) {
    if (isCancelled()) {
        onCancelled(result);
    } else {
        onPostExecute(result);
    }
    mStatus = Status.FINISHED;
}

@SuppressWarnings({"RawUseOfParameterizedType"})
private static class AsyncTaskResult<Data> {
    final AsyncTask mTask;
    final Data[] mData;

    AsyncTaskResult(AsyncTask task, Data... data) {
        mTask = task;
        mData = data;
    }
}

```

AsyncTask å†…éƒ¨å®ç°çš„ä¸€ä¸ª Handler , InternalHandler çš„ handleMessage æ–¹æ³•ä¸­ï¼Œæ ¹æ®æ¶ˆæ¯ç±»å‹åˆ†åˆ«æœ‰ä¸åŒçš„å¤„ç†

æ‰§è¡Œå™¨å¤„ç†å›ç»“æœé€šè¿‡handlerå‘é€æ¶ˆæ¯ handler é€šè¿‡æ¶ˆæ¯ç±»å‹è·å–æ•°æ®è¿›è¡Œä¸åŒçš„å›è°ƒ


4.æ„é€ å™¨

```java
private final WorkerRunnable<Params, Result> mWorker;
private final FutureTask<Result> mFuture;
    
/**
 * Creates a new asynchronous task. This constructor must be invoked on the UI thread.
 */
public AsyncTask() {
    mWorker = new WorkerRunnable<Params, Result>() {
        public Result call() throws Exception {
            mTaskInvoked.set(true);

            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            //noinspection unchecked
            Result result = doInBackground(mParams);
            Binder.flushPendingCommands();
            return postResult(result);
        }
    };

    mFuture = new FutureTask<Result>(mWorker) {
        @Override
        protected void done() {
            try {
                postResultIfNotInvoked(get());
            } catch (InterruptedException e) {
                android.util.Log.w(LOG_TAG, e);
            } catch (ExecutionException e) {
                throw new RuntimeException("An error occurred while executing doInBackground()",
                        e.getCause());
            } catch (CancellationException e) {
                postResultIfNotInvoked(null);
            }
        }
    };
}

@WorkerThread
protected abstract Result doInBackground(Params... params);

@WorkerThread
protected final void publishProgress(Progress... values) {
    if (!isCancelled()) {
        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
 Â  Â  Â  Â  Â  Â  Â  Â new AsyncTaskResult<Progress>(this, values)).sendToTarget();//å‘é€
 Â  Â }
}

private void postResultIfNotInvoked(Result result) {
    final boolean wasTaskInvoked = mTaskInvoked.get();
    if (!wasTaskInvoked) {
        postResult(result);
    }
}

private Result postResult(Result result) {
    @SuppressWarnings("unchecked")
    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
            new AsyncTaskResult<Result>(this, result));
 Â  Â message.sendToTarget();//handlerå‘é€æ¶ˆæ¯
 Â  Â return result;
}

private static Handler getHandler() {
    synchronized (AsyncTask.class) {
        if (sHandler == null) {
            sHandler = new InternalHandler();
        }
        return sHandler;
    }
}
```
åœ¨æ„é€ å™¨ä¸­åˆ›å»ºäº† WorkerRunnable å’Œ FutureTask çš„å¯¹è±¡ï¼Œè€Œåœ¨ WorkerRunnable å†…éƒ¨çš„ call æ–¹æ³•ä¸­ä¼šå»æ‰§è¡Œéœ€è¦æˆ‘ä»¬é‡å†™çš„ doInBackground æ–¹æ³•
æ¥ç€å°±æ˜¯å°†ç»“æœé€šè¿‡handlerå‘é€å¹¶æ‰§è¡Œå›è°ƒäº†

5.executeæ–¹æ³•æºç 

```java
@MainThread
public final AsyncTask<Params, Progress, Result> execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}

@MainThread
public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException("Cannot execute task:"
                        + " the task is already running.");
            case FINISHED:
                throw new IllegalStateException("Cannot execute task:"
                        + " the task has already been executed "
                        + "(a task can be executed only once)");
        }
    }

    mStatus = Status.RUNNING;

    onPreExecute();

    mWorker.mParams = params;
    exec.execute(mFuture);

    return this;
}

@MainThread
protected void onPreExecute() {
}
```

åœ¨ä¸Šé¢ä¸­å¯ä»¥çœ‹åˆ°æˆ‘ä»¬å¹³å¸¸ä½¿ç”¨çš„ execute æ–¹æ³•ä¼šå»è°ƒç”¨ executeOnExecutor æ–¹æ³•ã€‚è€Œåœ¨ executeOnExecutor æ–¹æ³•å†…åˆä¼šå»è°ƒç”¨ onPreExecute æ–¹æ³•ã€‚è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆ onPreExecute æ–¹æ³•æ˜¯åœ¨ä»»åŠ¡å¼€å§‹è¿è¡Œä¹‹å‰è°ƒç”¨çš„åŸå› äº†ã€‚

é»˜è®¤AsyncTaskæ˜¯ä¸²è¡Œæ‰§è¡Œä»»åŠ¡çš„ï¼Œè‹¥æƒ³å¹¶è¡Œæ‰§è¡Œ åªè¦é€‰å–å¹¶è¡Œæ‰§è¡Œå™¨å³å¯


All.


## å­çº¿ç¨‹çœŸçš„ä¸èƒ½æ›´æ–°UIå—ï¼Ÿ

å¦‚æœæˆ‘ä»¬åœ¨å­çº¿ç¨‹æ›´æ–°uiä¼šå‡ºç°ä¸‹é¢çš„é”™è¯¯ğŸ‘‡

```
android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views 
 at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6357)
 at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:874)
``` Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
æˆ‘ä»¬è·Ÿè¿›ä»£ç 

```java
void checkThread() {
    if (mThread != Thread.currentThread()) {//è¿™é‡Œåšäº†ä¸€ä¸ªåˆ¤æ–­
        throw new CalledFromWrongThreadException(
            "Only the original thread that created a view hierarchy can touch its views.");
        }
    }
```
mThread
```java
public ViewRootImpl(Context context, Display display) {
        mContext = context;
        mWindowSession = WindowManagerGlobal.getWindowSession();
        mDisplay = display;
        mBasePackageName = context.getBasePackageName();
        mDisplayAdjustments = display.getDisplayAdjustments();
        mThread = Thread.currentThread();//æ­¤å¤„åˆå§‹åŒ–
        ...
        }
```
é‚£ViewRootImplæ˜¯åœ¨ä½•æ—¶è¢«åˆå§‹åŒ–çš„å‘¢ï¼Ÿ

ä¸‹é¢æ˜¯ActivityThreadç±»ä¸‹çš„å‡½æ•°
```java
final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume) {
            ...
if (r.window == null && !a.mFinished && willBeVisible) {
                r.window = r.activity.getWindow();
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (a.mVisibleFromClient) {
                    a.mWindowAdded = true;
 Â  Â  Â  Â  Â  Â  Â  Â  Â  Â wm.addView(decor, l);//â¬…ï¸æ·±å…¥
 Â  Â  Â  Â  Â  Â  Â  Â }

            // If the window has already been added, but during resume
            // we started another activity, then don't yet make the
            // window visible.
            } else if (!willBeVisible) {
                if (localLOGV) Slog.v(
                    TAG, "Launch " + r + " mStartedActivity set");
                r.hideForNow = true;
            }
            ...
}
```
æ·±å…¥åˆ°WindowMangerImplçš„addview,ç»§ç»­æ·±å…¥
```java
  @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);//â¬…ï¸æ·±å…¥
    }
```
å‘ç°ä»–æ˜¯è°ƒç”¨WindowManagerGlobalçš„æ–¹æ³•å®ç°çš„ï¼Œæœ€åæˆ‘ä»¬æ‰¾åˆ°äº†æœ€ç»ˆå®ç°addViewçš„æ–¹æ³•ï¼š
Viewçš„åŠ è½½æœ€åå°±æ˜¯åœ¨è¿™é‡Œå®ç°çš„ï¼Œè€ŒViewRootImplçš„å®ä¾‹åŒ–ä¹Ÿåœ¨è¿™é‡ŒğŸ‘‡
```java
public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        ...
        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) {
            // Start watching for system property changes.
            ...
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
    }
```
åˆ°æ­¤å¤„ æˆ‘ä»¬å‘ç° ViewRootImplåˆå§‹åŒ–æ—¶ æ˜¯åœ¨ActivityThread,ActivityThreadä½œä¸ºappä»£ç çš„å…¥å£ æ˜¯åœ¨ä¸»çº¿ç¨‹è¿è¡Œçš„
å³ViewRootImplæŒæœ‰å¯¹ä¸»çº¿ç¨‹çš„å¼•ç”¨ å­çº¿ç¨‹ä¸­æ›´æ–°uiå› ä¸ºThread.currentThread()ä¸ºå­çº¿ç¨‹ å¹¶ä¸æ˜¯å­çº¿ç¨‹æ‰€ä»¥æŠ¥é”™

é‚£ææ¸…æ¥šäº†åŸå› ï¼Œæˆ‘ä»¬èƒ½å®ç°åœ¨å­çº¿ç¨‹æ›´æ–°uiå—ï¼Ÿ

æˆ‘ä»¬ç»è¿‡ä¸Šé¢çš„åˆ†æå·²ç»çŸ¥é“ å› ä¸ºçº¿ç¨‹çš„ä¸åŒå¯¼è‡´å¼‚å¸¸æ— æ³•æ·»åŠ view
ä¹‹å‰çš„windowè§£ææœºåˆ¶æˆ‘ä»¬çŸ¥é“åªæœ‰é€šè¿‡WindowManageræˆ‘ä»¬æ‰èƒ½å¯¹windowè¿›è¡Œæ“ä½œ
é‚£æˆ‘ä»¬å¯ä»¥ç›´æ¥è·³è¿‡åˆ¤æ–­ç›´æ¥è°ƒç”¨WindowManagerImpl.addviewç›´æ¥å°†æˆ‘ä»¬çš„è§†å›¾åŠ åˆ°windowä¸Š
é©¬ä¸ŠåŠ¨æ‰‹è¯•è¯•å§ï¼

```java
 new Thread(new Runnable() {
            @Override
            public void run() {
                Looper.prepare();
                TextView tx = new TextView(SecondActivity.this);
                tx.setText("å­çº¿ç¨‹");
                tx.setBackgroundColor(Color.WHITE);
                ViewManager viewManager = SecondActivity.this.getWindowManager();
                WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(
                        200, 200, 200, 200, WindowManager.LayoutParams.FIRST_SUB_WINDOW,
                        WindowManager.LayoutParams.TYPE_TOAST, PixelFormat.OPAQUE);
                viewManager.addView(tx,layoutParams);
                Looper.loop();
            }
        }).start();
```



![ç»“æœui](https://img-blog.csdn.net/20160628231001299)

æˆåŠŸäº†ï¼è°è¯´å­çº¿ç¨‹ä¸èƒ½æ›´æ–°uiï¼Œ ä½†æ˜¯æˆ‘ä»¬åªæ˜¯åœ¨è®ºè¯ä¸€ç§Androidç”¨ä¸»çº¿ç¨‹æ›´æ–°uiæœ‰å®ƒçš„ç†ç”±
å¤§æ¦‚æ˜¯å› ä¸ºå¦‚æœå­çº¿ç¨‹æ›´æ–°UIå¯èƒ½å¯¼è‡´çº¿ç¨‹ä¹‹é—´æŠ¢å¤ºèµ„æºå’Œæ­»é”ç­‰çº¿ç¨‹å®‰å…¨é—®é¢˜è€Œä¸å…è®¸åœ¨å­çº¿ç¨‹ä¸­æ›´æ–°UIå§

End.

###æ„Ÿè¨€

æºç çœŸçš„æ˜¯ä¸€ç¯å¥—ä¸€ç¯ å­¦çš„è¶Šå¤šä½ ä¼šå‘ç°çŸ¥è¯†ä½“ç³»æ˜¯è¿ç¯ç€çš„ æ­£æ˜¯è¿™äº›æ¨¡å—è¿æ¥è¿ä½œæ‰ä¼šæœ‰æˆ‘ä»¬å¦‚æ­¤ä¹‹æ£’çš„ç³»ç»Ÿå‡ºç° 

è¯»æºç çœŸçš„å¾ˆé‡è¦ æ‹¿ä»–äººçš„æˆæœä¸ºå—äººä»¥é±¼ è¯»ä»–äººè§£æçš„æ˜¯å­¦ä»–ä»¬çš„æ€è·¯ æ˜¯å­¦ä¹‹ä»¥æŠ€ è‡ªå·±è¯»æºç æ‰æ˜¯ å—å‡ ä»¥æ¸”

å¸Œæœ›ä½ æˆ‘éƒ½èƒ½åšä¸€ä¸ªçœŸæ­£çš„æ•é±¼äººã€‚

